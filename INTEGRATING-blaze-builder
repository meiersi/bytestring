
Integration of the blaze-builder work into 'bytestring' and a set of new
libraries.
========================================================================

[See the end of this file for an explanation of the splitting reasons.]

A package 'system-io-write':

  * compile-time abstraction of writing a bounded number of bytes to memory.

  System.IO.Write
    - provides both exact and bounded write abstractions


Extension to the 'bytestring' package:

  * also provide the ability to execute a builder on the buffer of a Handle;
    i.e., no buffer allocation required! This is not yet implemented in the
    blaze-builder library, as it requires changes to the Handle API. I think it
    is worthwhile to pursue, as it makes Builders full fledged IO citizens: it
    ensures a good buffer size even when executing multiple small builders
    sequentially.

  Data.ByteString.Builder.Internal.Buffer
    - provides the buffer abstraction used for running Puts and Builders
      (this buffer abstraction is also used by blaze-builder-enumerator)
      (which would become part of the 'enumerator' library once 'bytestring' provides
       the builder)

  Data.ByteString.Builder.Internal
    - provides the types up to Builder and Put
    - provides execution functions (toByteString, toLazyByteString)

  Data.ByteString.Builder.Write
    - conversion from writes to builders
    - higher-order functions for constructing bytestrings using writes
      (e.g., faster filter, map, unfoldr, .. for strict and lazy bytestrings)

  Data.ByteString.Builder
    - re-exports functions for using builders together with bytestrings
      (e.g., faster pack, map, filter, unfoldr, ... for lazy bytestrings)

  Data.ByteString.Put
    - re-exports functions for using Puts


A package 'encoding-writes'

  * allow sharing of implementation of binary encodings of Haskell values that 
    write only a statically bounded number of bytes.

  System.IO.Write.Char
    - utf8, utf16, utf32 with both-endiannesses
  System.IO.Write.Char8
    - write of the least-significant-byte (often used in low-level network
      protocol implementations)

  System.IO.Write.Int
    - binary writes of all sizes and byte orderings
  System.IO.Write.Word
    - binary writes of all sizes and byte orderings
  System.IO.Write.Float
    - binary writes of all sizes and byte orderings


A package 'encoding-builders' provides

  * builders for base types in encodings that are standardized.
  * Many of them are just lifted versions of the 'encoding-writes'

  Data.ByteString.Builder.Char
  Data.ByteString.Builder.Char8
    - also provides an IsString instance

  Data.ByteString.Builder.Int
  Data.ByteString.Builder.Word

  Data.ByteString.Builder.Base64
    - a faster on more flexible implementation of bytestring-base64


A package 'encoding-builders-http'

  * chunked transfer encoding used in 

  Data.ByteString.Builder.HTTP


A package 'encoding-builders-html'

  Data.ByteString.Builder.HTML  


Reasons for this splitting
--------------------------

The splitting is designed such that dependencies of different packages is
(almost) as small as possible.

  text: could reuse the UTF encoding writes together with a function
        'writeStream :: (Char -> Write) -> Text -> Builder'
        to define builders for serializing text values.

        deps: bytestring, encoding-writes, system-io-write

  blaze-html, hamlet: 
        use encoding-builders-html and encoding-builders to exploit fused HTML
        escaping and UTF-8 encoding.

        deps: bytestring, encoding-builders-html, encoding-builders

  warp, snap-server: 
        use the builder transformer for chunking builders according to the
        HTTP transfer encoding standard. They also use encoding-builders to
        build the bytestream for the headers.
       
        deps: bytestring, encoding-builders-http, encoding-builders

  zlib: 
        might not require encoding-builders, as all its writes to buffers are
        handled by the C implementation. Hence, only the builder abstraction
        for managing the allocation and filling of buffers is required.

        deps: bytestring
        

Open questions: 
  - Do system-io-write and encoding-writes need to be split? At least simple
    writes of WordXXX might be required in all use-cases.

  - Should WordXXX builders should be provided by bytestring?
    The Builder type is not really usable without these basic building blocks.

