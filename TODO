Todo items
----------

* state more clearly the null-termination property of strict ByteStrings
    - strings created via mallocByteString, generate or create will be
      null terminated. Strings created with slices, won't be.

* would it make sense to move the IO bits into a different module too?
        - System.IO.ByteString
        - Data.ByteString.IO

* pack/unpack -> fromList/toList ?
        - Don sez: i don't like it. pack/unpack is culturally significant :)

* can we avoid joinWithByte? 
        - Hard. Can't do it easily with a rule.

* think about Data.ByteString.hGetLines. is it needed in the presence of
    the cheap "lines =<< Data.ByteString.Lazy.getContents" ?

* unchunk, Data.ByteString.Lazy -> [Data.ByteString]
    -  and that'd work for any Lazy.ByteString, not just hGetContents >>= lines

* consider if lazy hGetContents should use non-blocking reads. This should
    allow messaging style applications (eg communication over pipes, sockets)
    to use lazy ByteStrings. I think that at the moment since we demand 64k
    it'd just block. With a messaging style app you've got to be careful not
    to demand more data than is available, hence using non-blocking read
    should do the right thing. And in the disk file case it doesn't change
    anything anyway, you can always get a full chunk.

* think about lazy hGetContents and IO exceptions

* should hGet(NonBlocking) realloc if the read is short?
  Or perhaps just if the read is 0.

* consider dropping map' as ghc-6.5 optimises map much better so there's now
  little difference between them (15% rather than 40%) and with the new fusion
  system we may be able to get even closer. Look at the benchmarks for filter'
  to see if we can do the same there.

--

* if we can be sure there is very little variance then it might be interesting to look 
 into the cases where we're doing slightly worse eg the map/up, filter/up cases
 and why we're doing so much better in the up/up case!?  that one makes no sense
 since we should be doing the exact same thing as the old loopU for the up/up
 case

* then there are the strictness issues eg our current foldl & foldr are
  arguably too strict we could fuse unpack/unpackWith if they wern't so strict

