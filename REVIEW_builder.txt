Hi guys,

first of all thanks for the feedback and the encouragment. I'm
looking forward to integrating it, getting more feedback, and
finally releasing this code.

I grouped the feedback into two sections: one on the 'Encoding'
abstraction and one for the rest.

1. The 'Encoding' abstraction --------------------------

First, let me clarify the purpose of 'Encoding's: they abstract
encodings of Haskell values whose maximal number of bytes written
is /independent/ of the actual value being encoded.

Having access to a value-independent bound on the number of bytes
written enables optimizations that are impossible otherwise. For
example, the buffer-size checks of two consecutive 'Encoding's can
be collated into a single check. This optimization will never be
performed by a built-in optimization of the compiler, as it is
not observationally equivalent (the chunk boundaries may change
due to the different buffer-size checks). Other optimizations
possible using this bound could in principle be performed by the
compiler. However, they require proofs that are way outside the
scope of current and possibly future compilers. See
'encodeByteStringWith' for an example where the live data in the
inner loop is reduced by coupling the end-pointers of the input
and output buffers. 

Hence, I conclude that the 'Encoding' abstraction won't be made
superfluous by future compiler optimizations. However, I also
conclude that its name is chosen rather badly, as it reflects the
internals of the type instead of its externally visible
properties. Therefore, I plan to rename the type 'Encoding a' to
'BoundedEncoding a' and move it to a module Codec.BoundedEncoding
or a module Data.Bounded.Encoding. What module name would you
prefer?

In this context, I also think that it is OK for 'BoundedEncoding'
to be a user visible type. It has a clear semantics and its
public combinators are used to implement efficient encodings that
perform escaping. See the documentation in
Data.ByteString.Builder.Encoding for an example. I agree that it is
better to internalize this library into bytestring. This leaves
us with the flexibility to transparently perform changes to its
internals. Is a module name like Codec.BoundedEncoding still
appropriate in this case?


2. Other questions/comments ---------------------------

> * Do we really need the ASCII/UTF8 type classes? Can't we just
> provide a few functions? As a general design principle I think
> we should be careful about adding new type classes in the base
> libraries. It's a lot more heavyweight in API terms than a few
> types and functions.

I understand. I have no strong opinion on this issue and will
give removing the type-classes a shot.

> * I think it would be clearer that the builders produce lazy
> bytestrings if the builder module hierarchy was rooted at
> Data.ByteString.Lazy.Builder. This would also be consistent
> with the naming of the builder in the text package.

That's a good suggestion. I'll apply that change.

> * I don't think D.B.Builder.foldMap should be exported from
> D.B.Builder. We typically don't do re-exports from other
> libraries and it "sticks out" a bit in the API given its
> general, non-builder related, type. It's fine to mention it in
> a comment.

OK. I'll remove this export.

> * I like the AllocationStrategy concept. I'm not sure why the
> second argument (the tail bytestring) in toLazyByteStringWith
> is needed.  Could you please elaborate? My guess is that it's
> an optimization of some sort. Do we have an important use case
> that's helped by this?

Yes, this enables switching to another generation mechanism for
lazy bytestrings in O(1) time instead of O(n). This follows the
general design principle that we should avoid terminating lazy
lists (and other lazy data-structures) too early, as otherwise
concatentation is asymptotically less efficient.

> * Is D.B.Builder.byteStringWith needed? Couldn't the caller
> just do (if B.length s < N then copyByteString s else
> insertByteString s)

Independent, of the implementation I think that this convenience
function is worth providing. Whether changing the implementation
according to your suggestion has an effect on the runtime is
unclear to me and has to be benchmarked. For now, I would just
leave it as-is to keep control over the implementation of this
function.

> * Do we need D.B.Builder.Int? Isn't e.g. int8 = word8 .
> fromIntegral?

This holds. However, as a library user, I deem it more
convenient, if the library author provides this convenience
function and has taken care of the proof that it really performs
a C++-style reinterpret_cast instead of googling it myself.
Moreover, for low-level protocols having concrete types instead
of the Intergral type-classes helps avoiding subtle errors.
Therefore, I'd keep this module and its functions.

> * D.B.Put: Does this module give you something that you
> couldn't implement using the public builder interface (e.g.
> D.B.Builder)?

Yes, 'Put's are are a suitable replacement for the 'Put' type
provided by Data.Binary.Put. It is more efficient, as it is
strict in its side-effect and doesn't just gather all the thunks
constituting the Builder before executing it. Moreover, for
encodings that require to return a value (e.g., an encoding error
or the remaining partial input-block of a block-wise encoding) a
'Builder' is not sufficiently expressive, but a 'Put' is.

Again, thanks for reviewing my code. I'm looking forward to
further feedback and CamHac.

best regards, Simon
