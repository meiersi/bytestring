------------------------------------------------------------------------
                       fps : Fast Packed Strings
------------------------------------------------------------------------

This library provides a FastPackedString library: byte arrays
manipulable as strings, providing very time and space efficient string
and IO operations.

Requirements:
        > Cabal

Building:
        > chmod +x Setup.hs
        > ./Setup.hs configure --prefix=/f/g
        > ./Setup.hs build
        > ./Setup.hs install

If you wish to use the mmap extensions, then as your first step.

        > mv fps.cabal.mmap fps.cabal

After installation, you can run the testsuite and benchmarks:

        > cd tests ; make ; make run

Authors:
    FastPackedString is derived from the GHC PackedString library, 
    originallly written by Bryan O'Sullivan, and then by Simon Marlow.
    It was adapted, and greatly extended for darcs by David Roundy, and
    others. Don Stewart cleaned up and further extended the implementation.

------------------------------------------------------------------------

Performance, some random numbers:

This table compares the performance of common operations in both
PackedString and FastPackedString, on various packed strings.

Size of test data: 21256k, Linux 3.2Ghz P4

                FPS2    FPS1    SPS     PS      [a]
++              0.078   ~       !       !       1.288   
length          0.000   ~       0.000   0.000   0.131   
pack            0.345   2.043   0.502   0.337   -       
unpack          1.596   ~       1.630   7.445   -       
compare         0.000   ~       0.000   0.000   0.000   
index           0.000   ~       0.000   0.000   0.000   
map             2.664   4.283   2.917   4.813   7.286   
filter          0.282   0.482   2.805   0.954   0.305   
take            0.000   ~       0.000   0.024   0.005   
drop            0.000   ~       0.000   11.768  0.130   
takeWhile       0.000   ~       1.498   0.000   0.000   
dropWhile       0.000   ~       1.985   8.447   0.130   
span            0.000   ~       9.289   11.144  0.131   
break           0.000   ~       9.383   11.268  0.133   
lines           0.421   ~       1.114   1.367   2.790   
unlines         0.121   ~       !       !       10.950  
words           2.115   3.202   2.128   5.644   4.184   
unwords         0.058   ~       !       !       1.305   
reverse         0.024   4.606   12.997  13.018  1.622   
concat          0.029   ~       12.701  11.459  1.163   
cons            0.016   3.094   2.064   8.358   0.131   
snoc            0.017   1.536   -       -       -       
empty           0.000   ~       0.000   0.000   0.000   
head            0.000   ~       0.000   0.000   0.000   
tail            0.000   ~       0.000   14.490  0.130   
last            0.000   ~       -       -       0.143   
init            0.000   ~       -       -       1.147   
inits           5.350   -       -       -       !       
tails           6.634   -       -       -       1.136   
intersperse     0.034   4.590   -       -       10.517  
concatMap       !       -       -       -       1.131   
any             0.000   ~       -       -       0.000   
all             0.000   ~       -       -       0.000   
sort            14.380  15.773  -       -       !
maximum         0.024   0.068   -       -       0.183
minimum         0.025   0.093   -       -       0.185
replicate       0.008   ~       -       -       0.053   
elem            0.000   ~       1.490   0.001   0.000   
find            0.278   0.366   -       -       0.000   
elemIndex       0.000   ~       -       -       0.000   
elemIndicies    0.224   4.192   -       -       0.314   


Key: FPS2 = Fast Packed String v2
     FPS1 = Fast Packed String v1
     SPS  = Simon Marlow's packedstring prototype
     PS   = Data.PackedString
     [a]  = [Char]

     ~    = unchanged from FPS2
     -    = no function exists
     !    = stack or memory exhaustion

------------------------------------------------------------------------

Question:
    Can I manipulate 1G strings in Haskell?

Short answer:
    Yes! Mostly.

Doing some stress testing of FPS, here are some results for 1G strings.

3.2Ghz box, 2G physical mem.
Size of input string: 1G

N.B. 2G of physical ram is not enough when trying to benchmark functions
that copy 1G strings around :)

    Function        Time in seconds

All O(1) functions:
    length          O
    index           0
    head            0
    tail            0
    last            0
    init            0

O(n) , but answer found early on:
    compare         0           
    any             0
    all             0
    elem            0
    elemIndex       0

O(n) mostly:
    maximum         3.855    
    minimum         4.666   
    filterChar      8.084   
    elemIndicies    11.504  
    lines           12.247  
    find            14.046  
    tails           27.328
    inits           33.620  
    words           100.963
    map toUpper     143.871

Failed due to memory exhaustion. 
Almost made it though, just need a tad more ram than I had.

    filter          !     
    unlines         !
    unwords         !
    reverse         !           -- copy
    cons            !           -- copy
    snoc            !           -- involves a copy
    ++              !           -- can't concat two 1G strings on this box

    sort            ? taking too long, but space was ok.

[Char] functions are much more costly.
    pack            !           -- constructing 1G [Char] is not ok.
    unpack          !            

Transforming 1 0.5G string into another requires holding both in memory:

Fine:
    filter          7.264
    unwords         1.715
    reverse         1.980
    cons            0.976
    snoc            0.689
    ++              2.845

Still wouldn't work at 0.5G
    unlines         !
    concat          !

Lesssons, you can play with 1G strings in Haskell. Having more than 2G
ram is useful though. Replacing higher order functions with hard coded
first order equivalents can help.

